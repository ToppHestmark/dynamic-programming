# Dynamic programming

Practical Javascript problem solving patterns.

### Memoization methods

Create a temporary store for the answer before returning the final output, this approach save a lot of time and memory.
The examples below solved the problems with the recurssion method.

- [x] [fibonacci](./memoization/fibonacci.js)
- [x] [gridTraveler](./memoization/gridTraveler.js)
- [x] [canSum](./memoization/canSum.js)
- [x] [howSum](./memoization/howSum.js)
- [x] [bestSum](./memoization/bestSum.js)
- [x] [canConstruct](./memoization/canConstruct.js)
- [x] [countConstruct](./memoization/countConstruct.js)
- [x] [allConstruct](./memoization/allConstruct.js)

### Tabulation methods

Create a table of the target value and iterate through the table to find the possible answer/possibilities/solutions.
Approah below may affect the efficiency due to nested for loops upon each other.

- [x] [fib](./tabulation/fib.js)
- [x] [gridTraveler](./tabulation/gridTraveler.js)
- [x] [canSum](./tabulation/canSum.js)
- [x] [howSum](./tabulation/howSum.js)
- [x] [bestSum](./tabulation/bestSum.js)
- [x] [canConstruct](./tabulation/canConstruct.js)
- [x] [countConstruct](./tabulation/countConstruct.js)
- [x] [allConstruct](./tabulation/allConstruct.js)
